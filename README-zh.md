voyant 是一个基于bpf指令集的动态追踪领域特定语言， 它具有如何特点:

- **轻量级**: 编译器和解析器全部手工完成，不借助任何编译器工具，比如yacc或者llvm， 这样做的目的就是为了保证项目的轻量级和简单。
- **语义清晰**: DSL会尽量的与通用的编程语言靠近, 同时会在一定的概念上进行扩展, 比如可以输出火焰图，直方图等信息。
- **兼容:** 保持一定的兼容性, 不会使用BPF的一些特别新的特性, 这是因为新的特性很好, 但是在一些比较低的版本上是无法运行的

**目前项目还处在一个很初级的阶段, 但是会越来越好的**

### Hello, World

out函数的底层是采用perf buffer 这一个数据结构的

```c
probe sys_enter_execve {
    out("%s", "hello, world");
}
```

### 变量

目前寄存器分配算法存在一些问题, 最好不要设置多个变量

```c
probe sys_enter_execve {
    a = 1;
    out("%d\n", a);
}
```

### 辅助函数

```c
probe sys_enter_execve {
    out("pid: %d, cpu: %d", pid(), cpu());
}
```

### map

- `map[comm()]`, 创建一个map, 它的键是`comm()`，它的值如过没有赋值会默认为0
- `|>` 这个操作符号表示方法调用的语义, 类似于Java中的`1.add()`的含义, 也就是将1这个对象传入这个`add()`方法中
    之所以这样设计是因为, 后续我们会支持多个函数进行层级调用, 用来实现组合函数的效果, 
    比如 `map[pid()] |> count(1) |> hist();`
- `count(1)` 表示每次加1


```c
probe sys_enter_execve {
    map[comm()] |> count(1);
}
```
